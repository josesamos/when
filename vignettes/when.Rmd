---
title: "Generating the *When Dimension* based on date and time tables"
date: "2024-01-08"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{Generating the *When Dimension* based on date and time tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The *When Dimension* plays a fundamental role in *Multidimensional Systems*, it allows us to express **when** the analysed focus of attention have occurred.

This dimension corresponds to the generically called “Time Dimension”, as named in @kimball1996data and @adamson2010star. Later it has also been called "Date Dimension" (date-based dimension) and "Time Dimension" (time-of-day-based dimension) to express granularity [@kimball2013data]. We prefer to call it "When Dimension" because granularity is not involved in that term.

Although conceptually the date and time can be represented together in a single dimension, in ROLAP (*Relational On-Line Analytical Processing*) systems, it is common to implement these concepts separately, sometimes in separate tables "to avoid a row count explosion in the date dimension" [@kimball2013data] by adding the time for each day.

In @kimball2013data these dimensions are considered *static dimensions*: they are built at the beginning of the project for the period under consideration and are referenced when adding the instances to the fact table. As mentioned there: "Typically, these dimensions are built in an afternoon with a spreadsheet."

The purpose of the `when` package is to assist in the implementation of the ***When Dimension*** in Multidimensional Systems implemented on a ROLAP star database, regardless of its granularity, with the following features:

- It supports the generation of tables with the granularity needed (second, minute, hour, date, week, month, quarter, semester or year) according to the relational star schema design criteria [@kimball2013data]. 

- We consider separate tables for **time-of-day** data and data obtained from **date** to avoid a row count explosion if a single table were used. 

- It can be used to generate tables **statically**, indicating a period, or **dynamically**, indicating data series. 

- In addition to attributes at the selected granularity, other attributes can be added at coarser granularity to facilitate querying. We can also add a surrogate key.

- We can obtain the tables in `tibble` format and in other formats (*xlsx*, *csv* or *Relational DBMS* table).

The rest of this document is structured as follows: First, the general process of defining these dimensions is presented. Next, we present dimension-specific aspects that we can configure, both for date-based and time-based dimensions. Finally, the document ends with conclusions and bibliography.

# Definition process

The definition process consists of the following steps:

1. Creating an object.
1. Definition  of general aspects.
1. Definition of instances.
1. Selection of levels and attributes.
1. Generation of the result.
1. Getting the table.

Steps 2, 3 and 4 can be done in any order, they can even be included in step 1.

Below we discuss each of them.

## Creating an object

The definition process begins by creating an object of the `when` class.

```{r setup}
library(when)

w_date <- when()
```

By default, an object is created based on date, but we can also create it based on time by indicating it using the `type` parameter.

```{r}
w_time <- when(type = 'time')
```

Virtually all configuration options can be defined using the object creation function. They can also be defined later using specific functions, as shown in the following section.

## Definition  of general aspects

For example, using the following combination of functions we get the same result as defining the type when we create the object.

```{r}
w_time_2 <- when() |>
  define_characteristics(type = 'time')

identical(w_time, w_time_2)
```

By default it considers the system language. Since our system is Spanish, for the literals of day and month names to appear in English, we must configure it explicitly.

```{r}
w_date <- w_date |>
  define_characteristics(locale = Sys.setlocale("LC_TIME", "English"))
```

Next we have to select and configure the levels and define the instances. These operations, along with the current one, can be performed in any order.

## Definition of instances

We can define the instances by giving a range of values or by indicating the specific instances. The values in both cases will depend on the type of dimension (date-based or time-based).

We can indicate these values at the time of creating the class object or through the `define_instances()` function.

- In the case of date, we can indicate a year, year and month (with the format `yyyy-mm`), or year month and day (`yyyy-mm-dd`).

- In the case of time, we can indicate an hour, hour and minute (with the format `hh:mm`), or hour, minute and second (`hh:mm:ss`).

In both cases we can use the string format, the one provided by the [`lubridate`](https://CRAN.R-project.org/package=lubridate) package or, when it is a single number (year or hour) we can use an integer value. Then it will be transformed appropriately.

For example, below they are used with the format of `lubridate`.

```{r}
w_date <- w_date |>
  define_instances(start = lubridate::today(),
                   end = lubridate::today() + lubridate::years(5))
```

The following definition will be appropriate if we want to obtain the dimension at the year level, because we are indicating the specific values to consider (not a period).

```{r}
w_date_2 <- w_date |>
  define_instances(values = 2020:2030)
```

The following definition will be appropriate at any level of detail because we are giving the range of values to consider (dates between those two years).

```{r}
w_date_3 <- w_date |>
  define_instances(start = 2020, end = 2030)
```

When only the year is indicated, it is considered its first day. Therefore the previous definition is equivalent to the following one.

```{r}
w_date_4 <- w_date |>
  define_instances(start = "2020-01-01", end = "2030-01-01")

identical(w_date_3, w_date_4)
```

In the case of time, by default, it is considered at second level and all seconds of the day.

```{r}
w_time_3 <- w_time |>
  define_instances(start = "00:00:00", end = "23:59:59")

identical(w_time, w_time_3)
```

We can also indicate a period or a set of times according to the indicated criteria. In the following example, the two definitions are equivalent.

```{r}
w_time_4 <- w_time |>
  define_instances(start = 8, end = 17)

w_time_5 <- w_time |>
  define_instances(start = "08:00:00", end = "17:00:00")

identical(w_time_4, w_time_5)
```


## Selection of levels and attributes

In the definition, by default, the attributes that we have considered to be most frequently used have been included. We can consult them for each level using the `get_level_attribute_names()` function with the parameter `selected = TRUE`. If we define the parameter as `selected = FALSE` (default option), it will return all available attributes. We can indicate the name of the level or, if we do not indicate any, it will obtain the attributes of all the levels. We obtain the level names using the `get_level_names()` function. Below are examples of using these functions for the date-based dimension.

```{r}
w_date |>
  get_level_attribute_names(selected = TRUE)

w_date |>
  get_level_names()

w_date |>
  get_level_attribute_names(name = 'month', selected = TRUE)

w_date |>
  get_level_attribute_names(name = 'month')
```

Also for the time-based dimension.

```{r}
w_time |>
  get_level_attribute_names()

w_time |>
  get_level_names()
```

There is a function to configure each level. We can select or deselect each attribute individually using the attribute name as a boolean parameter of the function. We can also select or deselect all attributes defined at the level using the special `include_all` and `exclude_all` parameters: Once all the attributes have been updated with these special parameters, in the same function call, we can select or deselect the attributes we want.

For example, if we do not want to include the name of the month, we can configure it using the `select_month_level()` function or at the time of object creation with a parameter of the same name, as shown below.

```{r}
w_date_5 <- w_date |>
  select_month_level(month_name = FALSE)

w_date_6 <- when(
  start = lubridate::today(),
  end = lubridate::today() + lubridate::years(5),
  month_name = FALSE
)

identical(w_date_5, w_date_6)

w_date_5 |>
  get_level_attribute_names(name = 'month', selected = TRUE)
```

If we only want to include the name of the month, we can do it as follows.

```{r}
w_date_7 <- w_date |>
  select_month_level(exclude_all = TRUE, month_name = TRUE)

w_date_7 |>
  get_level_attribute_names(name = 'month', selected = TRUE)
```

There is available a similar function for each level: time, date, week, month, quarter, semester and year. 

In the case of the date-based dimension levels, we can select or deselect them directly using the `select_date_levels()` function. It allows us to treat the levels globally in the same way that we have been treating the attributes. For example, to exclude the month level we can do the following.

```{r}
w_date_8 <- w_date |>
  select_date_levels(month_level = FALSE)

w_date_8 |>
  get_level_attribute_names(name = 'month', selected = TRUE)
```

We can also perform that same operation at object creation time, as shown below.

```{r}
w_date_9 <- when(
  start = lubridate::today(),
  end = lubridate::today() + lubridate::years(5),
  month_level = FALSE
)

identical(w_date_8, w_date_9)
```

In the case of a time-based dimension, as we have seen, we only consider one level called "time", as shown again below.

```{r}
w_time |>
  get_level_names()
```

We can configure the attributes it includes using the `select_time_level()` function. The attribute called "hour" must always be included. If we do not include the "minute" attribute then "second" will not be included either. Below are some examples of definition and the result obtained.

```{r}
w_time_6 <- w_time |>
  select_time_level(exclude_all = TRUE)

w_time_6 |>
  get_level_attribute_names(selected = TRUE)

w_time_7 <- w_time |>
  select_time_level(minute = FALSE)

w_time_7 |>
  get_level_attribute_names(selected = TRUE)
```



## Generation of the result

Once the characteristics of the dimension are defined, we can generate its table.

Although we have not yet generated the dimension table, the following function returns the names of the attributes it will contain. They can be obtained as a string or as a vector of strings.

```{r}
w_date |>
  get_table_attribute_names(as_string = FALSE)
```

If it is generated in the form of a string (`as_string = TRUE`, default option), the result can be used to easily change the name of the attributes, when the table is generated, using the `set_table_attribute_names()` function, if deemed necessary.

When we consider that the dimension is already properly defined, we can generate its corresponding table using the `generate_table()` function. We update the definition of the object. Any errors found will be notified to us.

```{r}
w_date <- w_date |>
  generate_table()

w_time <- w_time |>
  generate_table()
```

Once the table is generated, we can export it. If we want to access the table and it is not yet generated, it will send us an error message.

If we make changes to the configuration, it is our responsibility to generate the table again.

## Getting the table

We can access the dimension table to work with it in R (for example using the [`rolap`](https://CRAN.R-project.org/package=rolap) package), or export it in the format that is most convenient for us to work with other tools.

Next we access the generated tables and display them. First of all for the date.

```{r}
t_date <- w_date |>
  get_table()
```

The first and last rows of the obtained result are shown below.

```{r, results = "asis"}
pander::pandoc.table(rbind(head(t_date, 5), tail(t_date, 5)),
                     split.table = Inf)
```

Next for the time.

```{r}
t_time <- w_time |>
  get_table()
```

The start and end of the result table is shown below.

```{r, results = "asis"}
pander::pandoc.table(rbind(head(t_time, 5), tail(t_time, 5)),
                     split.table = Inf)
```

`day_part` is predefined in English. Literals or associated hours can be accessed and changed using the `get_day_part()` and `set_day_part()` functions.

We can take the generated tables to any Relational DBMS, as shown below, we just have to pass a connection to the database as a parameter.

```{r}
my_db <- DBI::dbConnect(RSQLite::SQLite())

w_date |>
  get_table_rdb(my_db)

w_time |>
  get_table_rdb(my_db)

DBI::dbListTables(my_db)

DBI::dbDisconnect(my_db)
```

In the previous example, since we have not explicitly defined any names for the tables in the configuration, they have been assigned as a name the element on which they are based (date or time).

Functions to get the tables in *xlsx* and *csv* format are also available: `get_table_xlsx()` and `get_table_csv()`.


# Other configuration options

By default the dimension table will include a surrogate key: Through the `surrogate_key` parameter of this function we can indicate that it is not included. Using the `name` parameter, also of this function, we can assign a name to the dimension table.

We have associated each hour with the usual part of the day in English. We can consult them and change them if necessary (for example, to define them in another language) using the `get_day_part()` and `set_day_part()` functions, as shown below.

```{r}
when() |>
  get_day_part()

when() |>
  set_day_part(hour = c(21:23, 0:4), name = "Noche") |>
  set_day_part(hour = c(13:20), name = "Tarde") |>
  get_day_part()
```



# Conclusions

`when` package offers a set of operations that allow us to generate the *When Dimension* based on date or time at the level of detail we need.

We create an object of the `when` class and, from it, we configure the instances and characteristics of the levels and attributes of the dimension. To define the instances we can indicate a range of values or provide the specific values from which to generate the rest of the attributes.

TAs a result, we can obtain tables for this dimension to work from R, for example with the [`rolap`](https://CRAN.R-project.org/package=rolap) package, or work in other environments, including Relational DBMSs.

# Bibliography

